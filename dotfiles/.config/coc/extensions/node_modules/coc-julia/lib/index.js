"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function checkPathExt(path2, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path2.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path2, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path2, options);
    }
    function isexe(path2, options, cb) {
      fs2.stat(path2, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path2, options));
      });
    }
    function sync(path2, options) {
      return checkStat(fs2.statSync(path2), path2, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function isexe(path2, options, cb) {
      fs2.stat(path2, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path2, options) {
      return checkStat(fs2.statSync(path2), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports, module2) {
    var fs2 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path2, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path2, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path2, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path2, options) {
      try {
        return core.sync(path2, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports, module2) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path2 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which2 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path2.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve, reject) => {
        if (ii === pathExt.length)
          return resolve(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve(p + ext);
          }
          return resolve(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path2.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate
});
module.exports = __toCommonJS(src_exports);
var import_coc2 = require("coc.nvim");

// src/ctx.ts
var import_child_process = require("child_process");
var import_coc = require("coc.nvim");
var import_fs = __toESM(require("fs"));
var import_os = __toESM(require("os"));
var import_path = __toESM(require("path"));
var import_which = __toESM(require_which());
var Config = class {
  constructor() {
    this.cfg = import_coc.workspace.getConfiguration("julia");
  }
  get enabled() {
    return this.cfg.get("enabled");
  }
  get executablePath() {
    return this.cfg.get("executablePath");
  }
  get environmentPath() {
    return this.cfg.get("environmentPath");
  }
};
var Ctx = class {
  constructor(context) {
    this.context = context;
    this.pkging = false;
    this.config = new Config();
    this.lsProj = import_path.default.join(context.extensionPath, "server");
    if (!import_fs.default.existsSync(context.storagePath)) {
      import_fs.default.mkdirSync(context.storagePath);
    }
    const version = this.resolveJuliaVersion();
    this.sysimgDir = import_path.default.join(context.storagePath, `sysimg-${version}`);
    if (!import_fs.default.existsSync(this.sysimgDir)) {
      import_fs.default.mkdirSync(this.sysimgDir);
    }
  }
  resolveJuliaBin() {
    let bin = this.config.executablePath;
    if (bin.startsWith("~")) {
      bin = import_os.default.homedir() + bin.slice(1);
    }
    if (bin && import_fs.default.existsSync(bin)) {
      return bin;
    }
    const cmd = process.platform === "win32" ? "julia.exe" : "julia";
    return import_which.default.sync(cmd, { nothrow: true });
  }
  resolveJuliaVersion() {
    const bin = this.resolveJuliaBin();
    const cmd = `${bin} --startup-file=no --history-file=no -e "println(VERSION)"`;
    return (0, import_child_process.execSync)(cmd).toString().trim();
  }
  formatPkg(vals) {
    const pkgs = [];
    for (const val of vals) {
      const parts = val.split(" ");
      if (parts.length === 4 || parts.length === 5) {
        pkgs.push({
          state: parts[0],
          hash: parts[1],
          name: parts[2],
          version: parts[3],
          repo: parts[4] || ""
        });
      }
    }
    return pkgs;
  }
  async resolveMissingPkgs(projPath) {
    const bin = this.resolveJuliaBin();
    let cmd = `${bin} --project="${projPath}" --startup-file=no --history-file=no -e "using Pkg; Pkg.status()"`;
    const pkgs = this.formatPkg((0, import_child_process.execSync)(cmd).toString().split("\n"));
    if (pkgs.some((p) => p.state === "\u2192")) {
      const ok = await import_coc.window.showPrompt(`Some LanguageServer.jl deps are missing, would you like to install now?`);
      if (ok) {
        this.pkging = true;
        cmd = `${bin} --project="${projPath}" --startup-file=no --history-file=no -e "using Pkg; Pkg.instantiate()"`;
        await import_coc.window.createTerminal({ name: "coc-julia-ls" }).then((t) => t.sendText(cmd));
      }
    }
  }
  resolveEnvPath() {
    if (this.config.environmentPath) {
      return this.config.environmentPath;
    }
    const bin = this.resolveJuliaBin();
    const cmd = `${bin} --project=@. --startup-file=no --history-file=no -e "using Pkg; println(dirname(Pkg.Types.Context().env.project_file))"`;
    return (0, import_child_process.execSync)(cmd).toString().trim();
  }
  resolveSysimgPath() {
    const sysimgs = {
      darwin: "sys.dylib",
      linux: "sys.so",
      win32: "sys.dll"
    };
    const sysimg_name = sysimgs[process.platform];
    const sysimg = import_path.default.join(this.sysimgDir, sysimg_name);
    if (import_fs.default.existsSync(sysimg)) {
      return sysimg;
    }
    const bin = this.resolveJuliaBin();
    const cmd = `${bin} --project=${this.lsProj} --startup-file=no --history-file=no -e "print(Base.Sys.BINDIR)"`;
    const bindir = (0, import_child_process.execSync)(cmd).toString().trim();
    return import_path.default.join(import_path.default.dirname(bindir), "lib", "julia", sysimg_name);
  }
  async compileServerSysimg(args) {
    import_coc.window.showInformationMessage("PackageCompiler.jl will take about 20 mins to compile...");
    const bin = this.resolveJuliaBin();
    await import_coc.window.createTerminal({ name: "coc-julia-ls" }).then((t) => {
      args.unshift(import_path.default.join(this.lsProj, "src", "exec.jl"));
      const files = args.join(" ");
      const cmd = `${bin} --project=${this.lsProj} ${import_path.default.join(this.lsProj, "src", "compile.jl")} -s ${this.lsProj} ${this.sysimgDir} ${files}`;
      t.sendText(cmd);
    });
  }
  prepareJuliaArgs() {
    const sysimg = this.resolveSysimgPath();
    const server = import_path.default.join(this.lsProj, "src", "server.jl");
    const args = ["--startup-file=no", "--history-file=no", `--sysimage=${sysimg}`, "--depwarn=no", `--project=${this.lsProj}`, server];
    const env = this.resolveEnvPath();
    const depopPath = process.env.JULIA_DEPOT_PATH ? process.env.JULIA_DEPOT_PATH : "";
    return args.concat([env, "--debug=no", depopPath, this.context.storagePath]);
  }
  async startServer() {
    await this.resolveMissingPkgs(this.lsProj);
    if (this.pkging)
      return;
    const command = this.resolveJuliaBin();
    const args = this.prepareJuliaArgs();
    const tmpdir = await import_coc.workspace.nvim.eval("$TMPDIR") || process.env.TMPDIR || process.env.TMP;
    const serverOptions = {
      command,
      args,
      options: { env: { ...process.env, TMPDIR: tmpdir } }
    };
    const clientOptions = {
      documentSelector: ["julia", "juliamarkdown"],
      initializationOptions: import_coc.workspace.getConfiguration("julia"),
      synchronize: {
        configurationSection: ["julia.lint"],
        fileEvents: import_coc.workspace.createFileSystemWatcher("**/*.{jl,jmd}")
      },
      progressOnInitialization: true,
      middleware: {
        provideCompletionItem: async (document, position, context, token, next) => {
          const option = context.option;
          const input = option.input.startsWith(option.word) ? option.input : option.word + option.input;
          const res = await next(document, position, context, token);
          const items = [];
          if (res && Array.isArray(res.items)) {
            for (const item of res.items) {
              if (item.textEdit && import_coc.TextEdit.is(item.textEdit) && (item.kind === 14 || item.kind === 17)) {
                const newText = item.textEdit.newText;
                if (!newText.startsWith(input)) {
                  const range = Object.assign({}, item.textEdit.range);
                  const start = import_coc.Position.create(range.start.line, range.start.character - input.length);
                  const end = import_coc.Position.create(range.end.line, range.end.character);
                  item.textEdit.newText = `${input}${newText}`;
                  item.textEdit.range = import_coc.Range.create(start, end);
                }
              }
              items.push(item);
            }
          }
          return { items, isIncomplete: res.isIncomplete };
        }
      }
    };
    const client = new import_coc.LanguageClient("julia", "Julia Language Server", serverOptions, clientOptions);
    this.context.subscriptions.push(import_coc.services.registLanguageClient(client));
  }
};

// src/index.ts
async function activate(context) {
  const ctx = new Ctx(context);
  if (!ctx.config.enabled)
    return;
  const bin = ctx.resolveJuliaBin();
  if (!bin) {
    import_coc2.window.showMessage(`Can't find julia`, "warning");
    return;
  }
  await ctx.startServer();
  context.subscriptions.push(
    import_coc2.commands.registerCommand("julia.CompileLanguageServerSysimg", async (...args) => {
      await ctx.compileServerSysimg(args);
    })
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
